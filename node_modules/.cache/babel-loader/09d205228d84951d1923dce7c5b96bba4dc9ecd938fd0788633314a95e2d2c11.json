{"ast":null,"code":"import { mapGetters } from 'vuex';\nimport moment from 'moment';\nexport default {\n  computed: {\n    ...mapGetters({\n      courtWithTimes: 'court/courtWithTimes'\n    })\n  },\n  methods: {\n    getAvailability(court, date, time) {\n      let count = 0;\n      let availableAt = null;\n      let unavailableAt = null;\n      if (this.courtWithTimes && court.id in this.courtWithTimes) {\n        // Get available court count\n        Object.keys(this.courtWithTimes[court.id]).forEach(courtNum => {\n          const dateAvailability = this.courtWithTimes[court.id][courtNum].find(record => record.date === date);\n          let isAvailable = false;\n          if (dateAvailability) {\n            dateAvailability.available_times.forEach(({\n              availability,\n              end_time,\n              start_time\n            }) => {\n              if (availability === 'Available') {\n                const startTime = moment(date + ' ' + start_time);\n                const endTime = moment(date + ' ' + end_time);\n                if (time.isBetween(startTime, endTime, undefined, '[)')) {\n                  isAvailable = true;\n                  if (!unavailableAt || endTime.isBefore(unavailableAt)) {\n                    unavailableAt = endTime;\n                  }\n                } else {\n                  if (!availableAt || startTime.isBefore(availableAt)) {\n                    availableAt = startTime;\n                  }\n                }\n              }\n            });\n          }\n          if (isAvailable) {\n            count++;\n          }\n        });\n      }\n      return {\n        availability: {\n          count,\n          availableAt,\n          unavailableAt\n        }\n      };\n    },\n    getTodayAvailability(court) {\n      const oneHourFromNow = moment().add(1, 'hours');\n      const today = oneHourFromNow.format('YYYY-MM-DD');\n      return this.getAvailability(court, today, oneHourFromNow);\n    },\n    getFreeCourt(court) {\n      const userUpdateTimeLimit = moment(court.updatedAt).add(20, 'minutes');\n      if (moment().isAfter(userUpdateTimeLimit)) {\n        // Use scraped data since free court number from user update is no longer valid\n        const {\n          availability\n        } = this.getTodayAvailability(court);\n        return availability.count;\n      } else {\n        return court.freeCourt || 0;\n      }\n    }\n  }\n};","map":{"version":3,"names":["mapGetters","moment","computed","courtWithTimes","methods","getAvailability","court","date","time","count","availableAt","unavailableAt","id","Object","keys","forEach","courtNum","dateAvailability","find","record","isAvailable","available_times","availability","end_time","start_time","startTime","endTime","isBetween","undefined","isBefore","getTodayAvailability","oneHourFromNow","add","today","format","getFreeCourt","userUpdateTimeLimit","updatedAt","isAfter","freeCourt"],"sources":["/Users/sharpie/Desktop/NetCoord Code/Testing/Latest code update/src/mixins/court-availability-mixin.js"],"sourcesContent":["import { mapGetters } from 'vuex';\nimport moment from 'moment'\n\nexport default {\n  computed: {\n    ...mapGetters({\n      courtWithTimes: 'court/courtWithTimes',\n    })\n  },\n  methods: {\n    getAvailability (court, date, time) {\n      let count = 0\n      let availableAt = null\n      let unavailableAt = null\n\n      if (this.courtWithTimes && court.id in this.courtWithTimes) {\n        // Get available court count\n        Object.keys(this.courtWithTimes[court.id]).forEach((courtNum) => {\n          const dateAvailability = this.courtWithTimes[court.id][courtNum].find(record => record.date === date)\n\n          let isAvailable = false\n          if (dateAvailability) {\n            dateAvailability.available_times.forEach(({ availability, end_time, start_time }) => {\n              if (availability === 'Available') {\n                const startTime = moment(date + ' ' + start_time);\n                const endTime = moment(date + ' ' + end_time);\n                \n                if (time.isBetween(startTime, endTime, undefined, '[)')) {\n                  isAvailable = true\n                  \n                  if (!unavailableAt || endTime.isBefore(unavailableAt)) {\n                    unavailableAt = endTime\n                  }\n                } else {\n                  if (!availableAt || startTime.isBefore(availableAt)) {\n                    availableAt = startTime\n                  }\n                }\n              }\n            })\n          }\n\n          if (isAvailable) {\n            count++\n          }\n        })\n      }\n      return {\n        availability: {\n          count,\n          availableAt,\n          unavailableAt\n        }\n      }\n    },\n    getTodayAvailability (court) {\n      const oneHourFromNow = moment().add(1, 'hours')\n      const today = oneHourFromNow.format('YYYY-MM-DD')\n      return this.getAvailability(court, today, oneHourFromNow)\n    },\n    getFreeCourt (court) {\n      const userUpdateTimeLimit = moment(court.updatedAt).add(20, 'minutes')\n\n      if(moment().isAfter(userUpdateTimeLimit)) {\n        // Use scraped data since free court number from user update is no longer valid\n        const { availability } = this.getTodayAvailability(court)\n        return availability.count;\n      } else {\n        return court.freeCourt || 0\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}